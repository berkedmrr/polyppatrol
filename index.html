<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <!-- Responsive scaling -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Polyp Patrol - Endoscopic Master</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background-color: black;
      height: 100%;
    }
    canvas {
      display: block;
      background-color: rgb(97,22,37);
    }
    footer {
      text-align: center;
      padding: 10px;
      background-color: #444;
      color: #fff;
      font-family: sans-serif;
      font-size: 14px;
    }
    .joystick-container {
      position: absolute;
      bottom: 20px;
      left: 20px;
      width: 150px;
      height: 150px;
      border-radius: 50%;
      background: rgba(255,255,255,0.1);
      touch-action: none;
      z-index: 10;
    }
    .joystick-handle {
      position: absolute;
      left: 50px;
      top: 50px;
      width: 50px;
      height: 50px;
      background: rgba(255,255,255,0.7);
      border-radius: 50%;
      pointer-events: none;
      transition: background 0.1s;
    }
    #hitButton {
      position: absolute;
      bottom: 20px;
      right: 20px;
      padding: 15px 25px;
      font-size: 18px;
      background: rgb(197,67,57);
      color: white;
      border: none;
      border-radius: 8px;
      z-index: 10;
      display: none;
    }
    /* Normal view: fullscreen button moved a little up (top: 10px) */
    #fullscreenButton {
      position: absolute;
      top: 10px;
      left: 20px;
      padding: 15px 30px;
      font-size: 18px;
      background: rgb(197,67,57);
      color: white;
      border: none;
      border-radius: 8px;
      z-index: 10;
    }
    /* In fullscreen mode, make the button 30% larger */
    :fullscreen #fullscreenButton {
      padding: 12px 25px;
      font-size: 23px;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas" width="1280" height="720"></canvas>
  <footer>This game is published by Berke Demir</footer>
  <div class="joystick-container" id="joystick">
    <div class="joystick-handle" id="joystickHandle"></div>
  </div>
  <button id="hitButton">Hit</button>
  <button id="fullscreenButton">Fullscreen</button>
  <script>
    // Fullscreen toggle function with fullscreenchange listener for canvas resizing
    function toggleFullScreen() {
      if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen().then(resizeCanvas);
      } else {
        document.exitFullscreen().then(resizeCanvas);
      }
    }
    document.getElementById("fullscreenButton").addEventListener("click", toggleFullScreen);
    document.addEventListener("fullscreenchange", resizeCanvas);

    // Global constants and game code remain unchanged
    const WIDTH = 1280;
    const HEIGHT = 720;
    const FPS = 60;
    const LEVEL_THRESHOLD = 10;
    const MAX_POLYPS = 50;
    const SPEED_FACTOR = 0.3;
    const MOVE_SPEED = 6;
    const COLORS = {
      text: 'rgb(255,255,255)',
      primary: 'rgb(197,67,57)',
      secondary: 'rgb(77,17,29)',
      accent: 'rgb(255,107,107)',
      background: 'rgb(97,22,37)',
      pause_overlay: 'rgba(0,0,0,0.7)'
    };

    let slowTimeFactor = 1;
    let crosshairX = WIDTH/2, crosshairY = HEIGHT/2;
    let joystickInput = { x: 0, y: 0 };
    let remainingTime = 50;

    const assets = {
      images: {
        background: "assets/backgrounds/background.jpg",
        diminutive: "assets/sprites/diminutive_polyp.png",
        small: "assets/sprites/small_polyp.png",
        intermediate: "assets/sprites/intermediate_polyp.png",
        large: "assets/sprites/large_polyp.png",
        boss: "assets/sprites/boss_polyp.png",
        poop: "assets/sprites/poop.png",
        powerup: "assets/sprites/powerup.png"
      },
      audio: {
        background: new Audio("assets/sounds/background.mp3"),
        correct: new Audio("assets/sounds/correct.wav"),
        wrong: new Audio("assets/sounds/wrong.wav"),
        select: new Audio("assets/sounds/select.wav"),
        warning: new Audio("assets/sounds/warning.wav"),
        powerup: new Audio("assets/sounds/powerup.wav")
      }
    };

    const images = {};
    for(let key in assets.images){
      images[key] = new Image();
      images[key].src = assets.images[key];
    }

    const GameState = {
      START: 0,
      PLAYING: 1,
      PAUSED_MANUAL: 3,
      GAME_OVER: 4,
      QUESTION: 5
    };

    const POLYP_TYPES = {
      diminutive: { info: "Diminutive Polyp (<5mm)\nLow cancer risk", points: 15, methods: ["Cold Snare", "Hot Biopsy", "Forceps", "EMR"], correct: "Cold Snare", size: { width: 60, height: 60 }, speed: 1.5 },
      small: { info: "Small Polyp (5-9mm)\nModerate cancer risk", points: 10, methods: ["Cold Snare", "Hot Snare", "Forceps", "EMR"], correct: "Cold Snare", size: { width: 140, height: 140 }, speed: 2.0 },
      intermediate: { info: "Intermediate Polyp (10-19mm)\nHigh cancer risk", points: 5, methods: ["Cold Snare", "Hot Snare", "EMR", "ESD"], correct: "EMR", size: { width: 180, height: 180 }, speed: 2.5 },
      large: { info: "Large Polyp (≥20mm)\nVery high cancer risk", points: 3, methods: ["Cold Snare", "Hot Snare", "EMR", "ESD"], correct: "ESD", size: { width: 200, height: 200 }, speed: 3.0 },
      boss: { info: "Boss Polyp!\nDefeat it for bonus points.", methods: ["ESD", "Cold Snare"], correct: "ESD", size: { width: 400, height: 400 }, speed: 1.0 }
    };

    function randRange(min, max){
      return Math.random()*(max-min)+min;
    }

    class Particle {
      constructor(x, y, color){
        this.x = x;
        this.y = y;
        this.color = Math.random() < 0.2 ? "white" : color;
        this.size = Math.random() * 6 + 4;
        this.life = 60;
        const speed = Math.random() * 6 + 4;
        const angle = Math.random() * Math.PI * 2;
        this.vx = speed * Math.cos(angle);
        this.vy = speed * Math.sin(angle);
        this.gravity = 0.4;
        this.friction = 0.98;
        this.alpha = 1.0;
      }
      update(){
        this.vy += this.gravity;
        this.x += this.vx;
        this.y += this.vy;
        this.vx *= this.friction;
        this.vy *= this.friction;
        this.life--;
        this.alpha = Math.max(this.life/60, 0);
        this.size = Math.max(this.size - 0.05, 0);
      }
      draw(ctx){
        if(this.life > 0 && this.size > 0){
          ctx.save();
          ctx.globalAlpha = this.alpha;
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.size, 0, Math.PI*2);
          ctx.fillStyle = this.color;
          ctx.fill();
          ctx.restore();
        }
      }
    }

    class Explosion {
      constructor(x, y, numParticles = 400){
        this.x = x;
        this.y = y;
        this.particles = [];
        for(let i=0;i<numParticles;i++){
          const color = Math.random() < 0.5 ? COLORS.primary : COLORS.accent;
          this.particles.push(new Particle(x, y, color));
        }
        this.shockwaveRadius = 0;
        this.shockwaveAlpha = 1;
      }
      update(){
        this.particles.forEach(p => p.update());
        this.particles = this.particles.filter(p => p.life > 0 && p.size > 0);
        this.shockwaveRadius += 4;
        this.shockwaveAlpha -= 0.02;
        if(this.shockwaveAlpha < 0) this.shockwaveAlpha = 0;
      }
      draw(ctx){
        if(this.shockwaveAlpha > 0){
          ctx.save();
          let gradient = ctx.createRadialGradient(this.x, this.y, this.shockwaveRadius*0.5, this.x, this.y, this.shockwaveRadius);
          gradient.addColorStop(0, `rgba(255,255,255,${this.shockwaveAlpha})`);
          gradient.addColorStop(1, 'rgba(255,255,255,0)');
          ctx.strokeStyle = gradient;
          ctx.lineWidth = 16;
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.shockwaveRadius, 0, Math.PI*2);
          ctx.stroke();
          ctx.restore();
        }
        this.particles.forEach(p => p.draw(ctx));
      }
      isFinished(){
        return this.particles.length === 0 && this.shockwaveAlpha <= 0;
      }
    }

    class ContaminationExplosion {
      constructor(x, y, numParticles = 100){
        this.x = x;
        this.y = y;
        this.particles = [];
        for(let i = 0; i < numParticles; i++){
          this.particles.push(new Particle(x, y, "red"));
        }
        this.shockwaveRadius = 0;
        this.shockwaveAlpha = 1;
      }
      update(){
        this.particles.forEach(p => p.update());
        this.particles = this.particles.filter(p => p.life > 0 && p.size > 0);
        this.shockwaveRadius += 2;
        this.shockwaveAlpha -= 0.03;
        if (this.shockwaveAlpha < 0) this.shockwaveAlpha = 0;
      }
      draw(ctx){
        if (this.shockwaveAlpha > 0) {
          ctx.save();
          let gradient = ctx.createRadialGradient(this.x, this.y, this.shockwaveRadius * 0.5, this.x, this.y, this.shockwaveRadius);
          gradient.addColorStop(0, `rgba(255,0,0,${this.shockwaveAlpha})`);
          gradient.addColorStop(1, 'rgba(255,0,0,0)');
          ctx.strokeStyle = gradient;
          ctx.lineWidth = 8;
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.shockwaveRadius, 0, Math.PI * 2);
          ctx.stroke();
          ctx.restore();
        }
        this.particles.forEach(p => p.draw(ctx));
      }
      isFinished(){
        return this.particles.length === 0 && this.shockwaveAlpha <= 0;
      }
    }

    class Polyp {
      constructor(ptype, speedMultiplier = 1.0){
        this.ptype = ptype;
        this.data = POLYP_TYPES[ptype];
        this.image = images[ptype];
        this.size = this.data.size;
        this.x = randRange(100, WIDTH - 200);
        this.y = randRange(100, HEIGHT - 200);
        this.dx = (Math.random() < 0.5 ? -1 : 1) * this.data.speed * speedMultiplier * SPEED_FACTOR;
        this.dy = (Math.random() < 0.5 ? -1 : 1) * this.data.speed * speedMultiplier * SPEED_FACTOR;
        this.rotSpeed = randRange(-1,1);
        this.rotation = 0;
        if(this.ptype === "boss"){
          this.health = 3;
        }
      }
      update(){
        this.x += this.dx * slowTimeFactor;
        this.y += this.dy * slowTimeFactor;
        if(this.x <= 0 || this.x + this.size.width >= WIDTH){
          this.dx *= -1;
        }
        if(this.y <= 0 || this.y + this.size.height >= HEIGHT){
          this.dy *= -1;
        }
        this.rotation = (this.rotation + this.rotSpeed) % 360;
      }
      draw(ctx){
        ctx.save();
        ctx.translate(this.x + this.size.width/2, this.y + this.size.height/2);
        ctx.rotate(this.rotation * Math.PI/180);
        ctx.drawImage(this.image, -this.size.width/2, -this.size.height/2, this.size.width, this.size.height);
        ctx.restore();
        if(this.ptype === "boss"){
          this.drawHealthBar(ctx);
        }
      }
      drawHealthBar(ctx){
        let barWidth = this.size.width;
        let barHeight = 10;
        let healthPct = this.health/3;
        ctx.fillStyle = 'red';
        ctx.fillRect(this.x, this.y-20, barWidth, barHeight);
        ctx.fillStyle = 'green';
        ctx.fillRect(this.x, this.y-20, barWidth * healthPct, barHeight);
      }
      isHit(pos){
        const cx = this.x + this.size.width/2;
        const cy = this.y + this.size.height/2;
        const distance = Math.hypot(pos.x-cx, pos.y-cy);
        return distance <= this.size.width/2;
      }
    }

    class Poop {
      constructor(){
        this.image = images.poop;
        this.size = POLYP_TYPES.large.size.width/2;
        this.x = randRange(100, WIDTH - 100);
        this.y = randRange(100, HEIGHT - 100);
        this.angle = 0;
        this.speed = 1;
      }
      update(){
        this.x += this.speed * slowTimeFactor;
        if(this.x + this.size/2 > WIDTH || this.x - this.size/2 < 0){
          this.speed *= -1;
        }
        this.angle = (this.angle + 5) % 360;
      }
      draw(ctx){
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle * Math.PI/180);
        ctx.drawImage(this.image, -this.size/2, -this.size/2, this.size, this.size);
        ctx.restore();
      }
      isHit(pos){
        const cx = this.x, cy = this.y;
        const distance = Math.hypot(pos.x-cx, pos.y-cy);
        return distance <= this.size/2;
      }
    }

    class PowerUp {
      constructor(){
        this.image = images.powerup;
        this.size = 50;
        this.x = randRange(100, WIDTH - 100);
        this.y = randRange(100, HEIGHT - 100);
        this.duration = FPS * 5;
        const effects = ["extra_life", "invincibility", "slow_time"];
        this.effect = effects[Math.floor(Math.random()*effects.length)];
      }
      update(){
        this.duration--;
      }
      draw(ctx){
        ctx.drawImage(this.image, this.x, this.y, this.size, this.size);
        ctx.strokeStyle = this.effect === "invincibility" ? 'rgb(0,191,255)' : COLORS.primary;
        ctx.lineWidth = 3;
        ctx.strokeRect(this.x, this.y, this.size, this.size);
      }
      isHit(pos){
        const cx = this.x + this.size/2, cy = this.y + this.size/2;
        const distance = Math.hypot(pos.x-cx, pos.y-cy);
        return distance <= this.size/2;
      }
    }

    class Button {
      constructor(x, y, width, height, text, callback){
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        this.text = text;
        this.callback = callback;
        this.hovered = false;
      }
      draw(ctx){
        ctx.fillStyle = this.hovered ? COLORS.primary : COLORS.secondary;
        ctx.fillRect(this.x, this.y, this.width, this.height);
        ctx.fillStyle = COLORS.text;
        ctx.font = "22px sans-serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(this.text, this.x+this.width/2, this.y+this.height/2);
      }
      handleEvent(eventType, pos){
        if(eventType==="mousemove"){
          this.hovered = (pos.x>=this.x && pos.x<=this.x+this.width && pos.y>=this.y && pos.y<=this.y+this.height);
        } else if(eventType==="click"){
          if(pos.x>=this.x && pos.x<=this.x+this.width && pos.y>=this.y && pos.y<=this.y+this.height){
            assets.audio.select.play();
            this.callback();
          }
        }
      }
    }

    class Game {
      constructor(ctx){
        this.ctx = ctx;
        this.state = GameState.START;
        this.polyps = [];
        this.poops = [];
        this.powerups = [];
        this.explosions = [];
        this.score = 0;
        this.level = 1;
        this.levelScore = 0;
        this.lives = 3;
        this.currentQuestion = null;
        this.questionBank = [
          { question: "What is the most common indication for an upper GI endoscopy?", choices: ["GERD", "Dyspepsia", "Barrett's esophagus", "Esophageal cancer"], correct: "Dyspepsia" },
          { question: "Which of the following is a common complication of colonoscopy?", choices: ["Perforation", "Myocardial infarction", "Stroke", "Appendicitis"], correct: "Perforation" },
          { question: "What does EGD stand for in gastroenterology?", choices: ["Esophagogastroduodenoscopy", "Enterogastroduodenoscopy", "Endoscopic Gastrointestinal Diagnosis", "Esophageal Gastric Duodenal"], correct: "Esophagogastroduodenoscopy" },
          { question: "Which procedure is used to visualize the biliary tree?", choices: ["Colonoscopy", "EGD", "ERCP", "Capsule Endoscopy"], correct: "ERCP" },
          { question: "What is the gold standard for diagnosing celiac disease?", choices: ["Serology", "Duodenal biopsy", "HLA typing", "Endoscopic ultrasound"], correct: "Duodenal biopsy" },
          { question: "Which endoscopic technique is most effective for removing large sessile colorectal polyps?", choices: ["Cold snare polypectomy", "Hot biopsy polypectomy", "Endoscopic submucosal dissection (ESD)", "Endoscopic mucosal resection (EMR)"], correct: "Endoscopic submucosal dissection (ESD)" },
          { question: "What is the primary advantage of ESD over EMR?", choices: ["Shorter procedure time", "En bloc resection", "Lower cost", "Easier technique"], correct: "En bloc resection" },
          { question: "In gastrointestinal endoscopy, which method is preferred for lesions with suspected submucosal invasion?", choices: ["EMR", "ESD", "Cold snare", "Forceps biopsy"], correct: "ESD" },
          { question: "Which imaging technique enhances visualization of vascular patterns in lesions?", choices: ["CT scan", "MRI", "Narrow Band Imaging (NBI)", "Ultrasound"], correct: "Narrow Band Imaging (NBI)" },
          { question: "At what minimum size is a polyp considered 'Large' in this game?", choices: ["5mm", "9mm", "19mm", "20mm"], correct: "20mm" }
        ];
        this.questionIndex = 0;
        this.levelUpTimer = 0;
        this.bgOffsetX = 0;
        this.remainingTime = 50;
        this.lastTime = performance.now();
        this.invincibleTimer = 0;
        this.slowTimeTimer = 0;
        this.powerupSpawnTimer = FPS * 10;
        this.errorTimer = 0;
        this.errorMessage = "";
        this.hurryUpTimer = 0;
        this.hurryUpTriggered = false;
        this.gameOverReason = "";
        this.bindEvents();
        this.background = images.background;
        this.initPolyps();
        this.spawnPoops();
      }
      shuffleQuestions(){
        for(let i = this.questionBank.length-1; i>0; i--){
          const j = Math.floor(Math.random()*(i+1));
          [this.questionBank[i], this.questionBank[j]] = [this.questionBank[j], this.questionBank[i]];
        }
      }
      initPolyps(){
        for(let i=0;i<8;i++){
          this.spawnPolyp();
        }
      }
      spawnPolyp(){
        if(this.polyps.length >= MAX_POLYPS) return;
        const types = Object.keys(POLYP_TYPES).filter(t => t !== "boss");
        const ptype = types[Math.floor(Math.random()*types.length)];
        let speedMultiplier = 1 + (this.level - 1)*0.1;
        this.polyps.push(new Polyp(ptype, speedMultiplier));
      }
      spawnPoops(){
        this.poops = [];
        for(let i=0;i<this.level*3;i++){
          this.poops.push(new Poop());
        }
      }
      spawnPowerUp(){
        this.powerups.push(new PowerUp());
      }
      resetGame(){
        this.polyps = [];
        this.poops = [];
        this.powerups = [];
        this.explosions = [];
        this.score = 0;
        this.level = 1;
        this.levelScore = 0;
        this.lives = 3;
        this.shuffleQuestions();
        this.questionIndex = 0;
        this.initPolyps();
        this.spawnPoops();
        this.remainingTime = 50;
        this.hurryUpTriggered = false;
        this.hurryUpTimer = 0;
        this.gameOverReason = "";
        this.state = GameState.START;
      }
      showError(message){
        this.errorMessage = message;
        this.errorTimer = FPS * 1.5;
      }
      handleHit(){
        const pos = { x: crosshairX, y: crosshairY };
        let validHit = false;
        for(let i=0; i<this.powerups.length; i++){
          if(this.powerups[i].isHit(pos)){
            assets.audio.powerup.play();
            if(this.powerups[i].effect === "extra_life"){
              this.lives = Math.min(this.lives+1,5);
              this.score += this.level * 5;
            } else if(this.powerups[i].effect === "invincibility"){
              this.invincibleTimer = FPS * 5;
            } else if(this.powerups[i].effect === "slow_time"){
              this.slowTimeTimer = FPS * 5;
            }
            this.powerups.splice(i,1);
            validHit = true;
            break;
          }
        }
        if(!validHit && this.boss && this.boss.isHit(pos)){
          assets.audio.correct.play();
          this.explosions.push(new Explosion(this.boss.x + this.boss.size.width/2, this.boss.y + this.boss.size.height/2));
          this.boss.health--;
          if(this.boss.health <= 0){
            this.score += this.level * 20;
            this.boss = null;
          }
          validHit = true;
        }
        if(!validHit){
          for(let i=0; i<this.polyps.length; i++){
            if(this.polyps[i].isHit(pos)){
              assets.audio.correct.play();
              this.explosions.push(new Explosion(this.polyps[i].x + this.polyps[i].size.width/2, this.polyps[i].y + this.polyps[i].size.height/2));
              const type = this.polyps[i].ptype;
              this.score += POLYP_TYPES[type].points;
              this.polyps.splice(i,1);
              this.spawnPolyp();
              this.levelScore++;
              if(this.levelScore >= LEVEL_THRESHOLD){
                this.levelUp();
              }
              validHit = true;
              break;
            }
          }
        }
        if(!validHit){
          let poopHit = false;
          for(let i=0; i<this.poops.length; i++){
            if(this.poops[i].isHit(pos)){
              assets.audio.warning.play();
              this.explosions.push(new ContaminationExplosion(this.poops[i].x + this.poops[i].size/2, this.poops[i].y + this.poops[i].size/2));
              this.poops.splice(i,1);
              poopHit = true;
              break;
            }
          }
          if(poopHit){
            this.lives--;
            if(this.lives <= 0){
              this.gameOverReason = "Game over from contamination!";
              this.state = GameState.GAME_OVER;
              this.createGameOverButtons();
            } else {
              this.showError("Contamination!");
            }
          } else {
            this.score = Math.max(this.score - 5, 0);
            this.showError("Contamination!");
          }
        }
      }
      showQuestionMenu(){
        this.state = GameState.QUESTION;
        this.currentQuestion = this.questionBank[this.questionIndex];
        this.questionIndex++;
        const menuWidth = 400, menuHeight = 400;
        const menuX = (WIDTH - menuWidth)/2;
        const menuY = (HEIGHT - menuHeight)/2;
        this.menuRect = { x: menuX, y: menuY, width: menuWidth, height: menuHeight };
        this.buttons = [];
        for(let i=0; i<this.currentQuestion.choices.length; i++){
          let choice = this.currentQuestion.choices[i];
          this.buttons.push(new Button(menuX+40, menuY+80+i*80,200,60, choice, ()=>this.handleQuestionAnswer(choice)));
        }
      }
      handleQuestionAnswer(answer){
        if(answer === this.currentQuestion.correct){
          this.level++;
          this.levelScore = 0;
          this.lives = Math.min(this.lives+1,5);
          this.spawnPoops();
          for(let i=0; i<2; i++){
            this.spawnPolyp();
          }
          if(this.level % 5 === 0){
            this.boss = new Polyp("boss");
          }
          this.levelUpTimer = 90;
          this.remainingTime = Math.max(50 - 10*(this.level-1), 20);
          this.hurryUpTriggered = false;
          this.hurryUpTimer = 0;
          this.state = GameState.PLAYING;
        } else {
          this.gameOverReason = "Incorrect answer! The correct answer was: " + this.currentQuestion.correct;
          this.state = GameState.GAME_OVER;
          this.createGameOverButtons();
        }
      }
      levelUp(){
        this.showQuestionMenu();
      }
      createGameOverButtons(){
        const menuWidth = 400, menuHeight = 200;
        const menuX = (WIDTH - menuWidth)/2;
        const menuY = (HEIGHT - menuHeight)/2 + 100;
        this.gameOverButtons = [
          new Button(menuX+50, menuY+150, menuWidth-100,50, "Return to Main Menu", ()=>this.resetGame())
        ];
      }
      drawInfoPanel(){
        // Hearts moved down (y position set to 70)
        this.ctx.textAlign = "left";
        this.ctx.font = "bold 40px sans-serif";
        for(let i=0; i<this.lives; i++){
          this.ctx.fillStyle = "red";
          this.ctx.fillText("♥", 20+i*45, 70);
        }
        this.ctx.textAlign = "right";
        this.ctx.font = "bold 40px sans-serif";
        this.ctx.fillStyle = "white";
        this.ctx.fillText("Score: " + this.score, WIDTH-20, 40);
        this.ctx.textAlign = "center";
        this.ctx.font = "bold 40px sans-serif";
        this.ctx.fillStyle = "white";
        let secondsLeft = Math.ceil(this.remainingTime);
        this.ctx.fillText("Time: " + secondsLeft, WIDTH/2, 40);
      }
      drawCrosshair(){
        let color = "white";
        let pos = { x: crosshairX, y: crosshairY };
        for(let poly of this.polyps){
          if(poly.isHit(pos)){
            color = "red";
            break;
          }
        }
        if(color === "white"){
          for(let pu of this.powerups){
            if(pu.isHit(pos)){
              color = "red";
              break;
            }
          }
        }
        this.ctx.strokeStyle = color;
        this.ctx.lineWidth = 2;
        this.ctx.beginPath();
        this.ctx.moveTo(crosshairX-20, crosshairY);
        this.ctx.lineTo(crosshairX+20, crosshairY);
        this.ctx.moveTo(crosshairX, crosshairY-20);
        this.ctx.lineTo(crosshairX, crosshairY+20);
        this.ctx.stroke();
      }
      drawTutorialMenu(){
        this.ctx.fillStyle = "#330000";
        this.ctx.fillRect(0,0,WIDTH,HEIGHT);
        this.ctx.fillStyle = "white";
        this.ctx.font = "48px sans-serif";
        this.ctx.textAlign = "center";
        this.ctx.fillText("Polyp Patrol Tutorial", WIDTH/2, HEIGHT/4);
        this.ctx.font = "24px sans-serif";
        const infoLines = [
          "Use the joystick to move the crosshair.",
          "Press the Hit button to target objects.",
          "Avoid contamination – if you click on a poop or empty space, you lose 5 points.",
          "Point Mechanics: Diminutive = 15, Small = 10, Intermediate = 5, Large = 3, Boss gives bonus points."
        ];
        let y = HEIGHT/2 - 20;
        for(let line of infoLines){
          this.ctx.fillText(line, WIDTH/2, y);
          y += 40;
        }
        const buttonY = HEIGHT*0.75+100;
        this.ctx.fillStyle = "black";
        this.ctx.fillRect(WIDTH/2 - 100, buttonY, 200, 50);
        this.ctx.fillStyle = "white";
        this.ctx.font = "24px sans-serif";
        this.ctx.textAlign = "center";
        this.ctx.textBaseline = "middle";
        this.ctx.fillText("Click here to start", WIDTH/2, buttonY+25);
      }
      drawQuestionMenu(){
        this.ctx.fillStyle = "rgba(0,0,0,0.5)";
        this.ctx.fillRect(0,0,WIDTH,HEIGHT);
        const headerHeight = 100;
        this.ctx.fillStyle = "white";
        this.ctx.fillRect(0,0,WIDTH,headerHeight);
        this.ctx.fillStyle = "black";
        this.ctx.font = "20px sans-serif";
        this.ctx.textAlign = "center";
        this.ctx.fillText(this.currentQuestion.question, WIDTH/2, headerHeight/2);
        if(this.menuRect){
          this.ctx.fillStyle = COLORS.background;
          this.ctx.fillRect(this.menuRect.x, this.menuRect.y, this.menuRect.width, this.menuRect.height);
        }
        this.ctx.fillStyle = COLORS.text;
        this.ctx.font = "24px sans-serif";
        this.ctx.textAlign = "center";
        this.ctx.fillText("Select Answer", WIDTH/2, this.menuRect.y+30);
        for(let btn of this.buttons){
          btn.draw(this.ctx);
        }
      }
      drawGameOver(){
        this.ctx.fillStyle = "rgba(0,0,0,0.8)";
        this.ctx.fillRect(0,0,WIDTH,HEIGHT);
        this.ctx.fillStyle = COLORS.accent;
        this.ctx.font = "48px sans-serif";
        this.ctx.textAlign = "center";
        this.ctx.fillText("Game Over!", WIDTH/2, HEIGHT/2-50);
        this.ctx.font = "36px sans-serif";
        this.ctx.fillStyle = COLORS.text;
        this.ctx.fillText(`Final Score: ${this.score}`, WIDTH/2, HEIGHT/2);
        this.ctx.font = "28px sans-serif";
        this.ctx.fillStyle = COLORS.text;
        this.ctx.fillText(this.gameOverReason, WIDTH/2, HEIGHT/2 + 50);
        for(let btn of this.gameOverButtons){
          btn.draw(this.ctx);
        }
      }
      drawPauseMenu(){
        this.ctx.fillStyle = COLORS.pause_overlay;
        this.ctx.fillRect(0,0,WIDTH,HEIGHT);
        const menuWidth = 400, menuHeight = 200;
        const menuX = (WIDTH-menuWidth)/2;
        const menuY = (HEIGHT-menuHeight)/2;
        this.ctx.fillStyle = COLORS.background;
        this.ctx.fillRect(menuX, menuY, menuWidth, menuHeight);
        this.ctx.fillStyle = COLORS.text;
        this.ctx.font = "36px sans-serif";
        this.ctx.textAlign = "center";
        this.ctx.fillText("Paused", WIDTH/2, menuY+40);
        for(let btn of this.pauseButtons){
          btn.draw(this.ctx);
        }
      }
      bindEvents(){
        const handleClick = (pos) => {
          if(this.state === GameState.PLAYING) return;
          if(this.state === GameState.GAME_OVER){
            this.gameOverButtons.forEach(btn => btn.handleEvent("click", pos));
          } else if(this.state === GameState.QUESTION){
            this.buttons.forEach(btn => btn.handleEvent("click", pos));
          } else if(this.state === GameState.PAUSED_MANUAL){
            this.pauseButtons.forEach(btn => btn.handleEvent("click", pos));
          } else if(this.state === GameState.START){
            this.state = GameState.PLAYING;
            assets.audio.background.loop = true;
            assets.audio.background.play();
          }
        };

        canvas.addEventListener("click", (e)=>{
          let rect = canvas.getBoundingClientRect();
          let scaleX = canvas.width/rect.width;
          let scaleY = canvas.height/rect.height;
          let pos = { x: (e.clientX - rect.left)*scaleX, y: (e.clientY - rect.top)*scaleY };
          handleClick(pos);
        });

        canvas.addEventListener("touchstart", (e)=>{
          e.preventDefault();
          let touch = e.touches[0];
          let rect = canvas.getBoundingClientRect();
          let scaleX = canvas.width/rect.width;
          let scaleY = canvas.height/rect.height;
          let pos = { x: (touch.clientX - rect.left)*scaleX, y: (touch.clientY - rect.top)*scaleY };
          handleClick(pos);
        }, { passive: false });

        window.addEventListener("keydown", (e)=>{
          if(this.state === GameState.START && e.code === "Space"){
            this.state = GameState.PLAYING;
            assets.audio.background.loop = true;
            assets.audio.background.play();
          } else if(this.state === GameState.PLAYING && e.code === "KeyP"){
            this.state = GameState.PAUSED_MANUAL;
            this.createPauseButtons();
          } else if(this.state === GameState.PAUSED_MANUAL && e.code === "KeyP"){
            this.resumeGame();
          }
        });
      }
      update(){
        let now = performance.now();
        let dt = (now - this.lastTime) / 1000;
        this.lastTime = now;
        if(this.errorTimer > 0){
          this.errorTimer--;
        }
        if(!this.hurryUpTriggered && this.remainingTime <= 10){
          this.hurryUpTimer = FPS * 0.5;
          this.hurryUpTriggered = true;
        }
        if(this.hurryUpTimer > 0){
          this.hurryUpTimer--;
        }
        if(this.state === GameState.PLAYING){
          crosshairX += joystickInput.x * MOVE_SPEED;
          crosshairY += joystickInput.y * MOVE_SPEED;
          crosshairX = Math.max(0, Math.min(WIDTH, crosshairX));
          crosshairY = Math.max(0, Math.min(HEIGHT, crosshairY));
          if(this.remainingTime > 0){
            this.remainingTime -= dt;
          } else {
            this.gameOverReason = "Time's up!";
            this.state = GameState.GAME_OVER;
            this.createGameOverButtons();
          }
        }
        if(this.slowTimeTimer > 0){
          this.slowTimeTimer--;
          slowTimeFactor = 0.5;
        } else {
          slowTimeFactor = 1;
        }
        if(this.invincibleTimer > 0){
          this.invincibleTimer--;
        }
        if(this.state === GameState.PLAYING){
          for(let i=this.powerups.length-1; i>=0; i--){
            this.powerups[i].update();
            if(this.powerups[i].duration <= 0){
              this.powerups.splice(i,1);
            }
          }
          this.powerupSpawnTimer--;
          if(this.powerupSpawnTimer <= 0){
            this.spawnPowerUp();
            this.powerupSpawnTimer = FPS * 10;
          }
          this.poops.forEach(poop=>{ poop.update(); });
          this.polyps.forEach(polyp=>{ polyp.update(); });
          if(this.boss) this.boss.update();
        }
        this.explosions.forEach(exp => exp.update());
        this.explosions = this.explosions.filter(exp => !exp.isFinished());
        if(this.levelUpTimer > 0){
          this.levelUpTimer--;
        }
        if(this.background && this.background.complete){
          this.bgOffsetX += 1;
          if(this.bgOffsetX > this.background.width){
            this.bgOffsetX = 0;
          }
        }
      }
      draw(){
        this.ctx.clearRect(0,0,WIDTH,HEIGHT);
        if(this.background && this.background.complete){
          for(let x = this.bgOffsetX - this.background.width; x < WIDTH; x += this.background.width){
            this.ctx.drawImage(this.background, x, 0, this.background.width, HEIGHT);
          }
        } else {
          this.ctx.fillStyle = COLORS.background;
          this.ctx.fillRect(0, 0, WIDTH, HEIGHT);
        }
        if(this.state === GameState.START){
          this.drawTutorialMenu();
        } else if(this.state === GameState.PLAYING){
          this.powerups.forEach(p => p.draw(this.ctx));
          this.poops.forEach(p => p.draw(this.ctx));
          this.polyps.forEach(p => p.draw(this.ctx));
          if(this.boss) this.boss.draw(this.ctx);
          this.explosions.forEach(exp => exp.draw(this.ctx));
          this.drawInfoPanel();
          this.drawCrosshair();
          if(this.levelUpTimer > 0){
            this.ctx.save();
            this.ctx.font = "bold 50px monospace";
            this.ctx.fillStyle = "white";
            this.ctx.textAlign = "center";
            this.ctx.fillText("LEVEL UP!", WIDTH/2, HEIGHT/2);
            this.ctx.restore();
          }
          if(this.hurryUpTimer > 0){
            this.ctx.save();
            this.ctx.font = "bold 60px sans-serif";
            let alpha = this.hurryUpTimer / (FPS * 0.5);
            this.ctx.fillStyle = "rgba(255,255,0," + alpha + ")";
            this.ctx.textAlign = "center";
            this.ctx.fillText("Hurry up!", WIDTH/2, HEIGHT/2 - 100);
            this.ctx.restore();
          }
          if(this.errorTimer > 0 && this.errorMessage){
            this.ctx.save();
            this.ctx.font = "bold 60px sans-serif";
            this.ctx.fillStyle = "rgba(255,0,0," + (this.errorTimer/(FPS*1.5)) + ")";
            this.ctx.textAlign = "center";
            this.ctx.fillText(this.errorMessage, WIDTH/2, HEIGHT/2);
            this.ctx.restore();
          }
        } else if(this.state === GameState.QUESTION){
          this.drawQuestionMenu();
        } else if(this.state === GameState.PAUSED_MANUAL){
          this.drawPauseMenu();
        } else if(this.state === GameState.GAME_OVER){
          this.drawGameOver();
        }
      }
      run(){
        this.lastTime = performance.now();
        const loop = () => {
          this.update();
          this.draw();
          document.getElementById("hitButton").style.display = (this.state === GameState.PLAYING) ? "block" : "none";
          requestAnimationFrame(loop);
        }
        loop();
      }
    }

    const joystick = document.getElementById('joystick');
    const joystickHandle = document.getElementById('joystickHandle');
    const maxDistance = joystick.offsetWidth/2;
    let joystickActive = false;

    function getNormalizedVector(dx, dy){
      const distance = Math.hypot(dx,dy);
      const clamped = Math.min(distance, maxDistance);
      const angle = Math.atan2(dy,dx);
      return {
        x: (clamped*Math.cos(angle))/maxDistance,
        y: (clamped*Math.sin(angle))/maxDistance
      };
    }

    function updateJoystick(clientX, clientY){
      const rect = joystick.getBoundingClientRect();
      const centerX = rect.left+rect.width/2;
      const centerY = rect.top+rect.height/2;
      const dx = clientX-centerX;
      const dy = clientY-centerY;
      const distance = Math.hypot(dx,dy);
      let limitedX = dx, limitedY = dy;
      if(distance > maxDistance){
        const angle = Math.atan2(dy,dx);
        limitedX = Math.cos(angle)*maxDistance;
        limitedY = Math.sin(angle)*maxDistance;
      }
      joystickHandle.style.transform = `translate(${limitedX}px, ${limitedY}px)`;
      joystickInput = getNormalizedVector(dx,dy);
      console.log('Joystick:', joystickInput);
    }

    function resetJoystick(){
      joystickHandle.style.transform = `translate(0px, 0px)`;
      joystickInput = { x: 0, y: 0 };
    }

    joystick.addEventListener('touchstart', (e)=>{
      joystickActive = true;
      const touch = e.changedTouches[0];
      updateJoystick(touch.clientX, touch.clientY);
      e.preventDefault();
    });
    joystick.addEventListener('touchmove', (e)=>{
      if(!joystickActive)return;
      const touch = e.changedTouches[0];
      updateJoystick(touch.clientX, touch.clientY);
      e.preventDefault();
    });
    joystick.addEventListener('touchend', (e)=>{
      joystickActive = false;
      resetJoystick();
      e.preventDefault();
    });
    joystick.addEventListener('mousedown', (e)=>{
      joystickActive = true;
      updateJoystick(e.clientX, e.clientY);
      e.preventDefault();
    });
    window.addEventListener('mousemove', (e)=>{
      if(!joystickActive)return;
      updateJoystick(e.clientX, e.clientY);
    });
    window.addEventListener('mouseup', (e)=>{
      if(joystickActive){
        joystickActive = false;
        resetJoystick();
      }
    });
    document.getElementById("hitButton").addEventListener("click", ()=>{
      game.handleHit();
    });
    function resizeCanvas(){
      const canvas = document.getElementById("gameCanvas");
      const gameWidth = 1280;
      const gameHeight = 720;
      const scale = Math.min(window.innerWidth/gameWidth, window.innerHeight/gameHeight);
      canvas.style.transform = `scale(${scale})`;
      canvas.style.transformOrigin = "top left";
      canvas.style.position = "absolute";
      canvas.style.left = `${(window.innerWidth - gameWidth*scale)/2}px`;
      canvas.style.top = `${(window.innerHeight - gameHeight*scale)/2}px`;
    }
    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();

    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    const game = new Game(ctx);
    game.run();
  </script>
</body>
</html>
